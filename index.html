<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü©∫ Healthcare Translation Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .settings {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            align-items: center;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-group label {
            font-weight: 600;
            color: #333;
        }

        select, input {
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .main-content {
            padding: 30px;
        }

        .translation-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .translation-section {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            transition: transform 0.3s ease;
        }

        .translation-section:hover {
            transform: translateY(-2px);
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
        }

        .record-button {
            background: linear-gradient(135deg, #FF6B6B, #FF8E8E);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            width: 100%;
        }

        .record-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 107, 107, 0.4);
        }

        .record-button.recording {
            background: linear-gradient(135deg, #FF4444, #CC3333);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.4); }
            70% { box-shadow: 0 0 0 15px rgba(255, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); }
        }

        .text-input {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            resize: vertical;
            margin-bottom: 15px;
        }

        .submit-button {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .submit-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }

        .result-box {
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            min-height: 60px;
        }

        .result-box.original {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .result-box.translated {
            border-color: #28a745;
            background: #f0fff4;
        }

        .result-label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        .conversation-history {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        .conversation-item {
            border-left: 4px solid #4CAF50;
            padding: 20px;
            margin-bottom: 20px;
            background: #f8f9fa;
            border-radius: 0 10px 10px 0;
            transition: all 0.3s ease;
        }

        .conversation-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .conversation-item.doctor {
            border-left-color: #007bff;
        }

        .conversation-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-weight: 600;
            color: #666;
        }

        .conversation-content {
            display: grid;
            gap: 10px;
        }

        .speak-button {
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .speak-button:hover {
            transform: scale(1.05);
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #b3d7ff;
        }

        @media (max-width: 768px) {
            .translation-grid {
                grid-template-columns: 1fr;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .container {
                margin: 10px;
                border-radius: 15px;
            }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü©∫ Healthcare Translation Assistant</h1>
            <p class="subtitle">Real-time Patient ‚Üî Doctor Communication</p>
        </div>

        <div class="settings">
            <div class="settings-grid">
                <div class="form-group">
                    <label for="inputLang">Patient Language:</label>
                    <select id="inputLang">
                        <option value="ur">Urdu</option>
                        <option value="en">English</option>
                        <option value="hi">Hindi</option>
                        <option value="ar">Arabic</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="outputLang">Clinician Language:</label>
                    <select id="outputLang">
                        <option value="en" selected>English</option>
                        <option value="ur">Urdu</option>
                        <option value="hi">Hindi</option>
                        <option value="ar">Arabic</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="openaiKey">OpenAI API Key (Optional):</label>
                    <input type="password" id="openaiKey" placeholder="sk-... (for better accuracy)">
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="translation-grid">
                <!-- Patient Section -->
                <div class="translation-section">
                    <div class="section-header">
                        <span>üßë</span>
                        <span>Patient ‚Üí Clinician</span>
                    </div>
                    
                    <button class="record-button" id="patientRecord">
                        üéôÔ∏è Record Patient
                    </button>
                    
                    <div class="result-box original">
                        <div class="result-label">Original (Patient):</div>
                        <div id="patientOriginal">Click record to start...</div>
                        <button class="speak-button hidden" id="playPatientOriginal">
                            üéß Play Recording
                        </button>
                    </div>
                    
                    <div class="result-box translated">
                        <div class="result-label">For Clinician:</div>
                        <div id="patientTranslated">Translation will appear here...</div>
                    </div>
                    
                    <button class="speak-button hidden" id="speakPatient">
                        üîä Speak Translation
                    </button>
                </div>

                <!-- Doctor Section -->
                <div class="translation-section">
                    <div class="section-header">
                        <span>üë©‚Äç‚öïÔ∏è</span>
                        <span>Clinician ‚Üí Patient</span>
                    </div>
                    
                    <div class="form-group">
                        <label>
                            <input type="radio" name="doctorInput" value="text" checked> Type Message
                        </label>
                        <label>
                            <input type="radio" name="doctorInput" value="voice"> Record Voice
                        </label>
                    </div>
                    
                    <div id="textInputSection">
                        <textarea class="text-input" id="doctorText" placeholder="Type your message to the patient..."></textarea>
                        <button class="submit-button" id="submitDoctorText">
                            ‚û°Ô∏è Translate & Send
                        </button>
                    </div>
                    
                    <div id="voiceInputSection" class="hidden">
                        <button class="record-button" id="doctorRecord">
                            üéôÔ∏è Record Clinician
                        </button>
                    </div>
                    
                    <div class="result-box original">
                        <div class="result-label">Original (Clinician):</div>
                        <div id="doctorOriginal">Enter message above...</div>
                        <button class="speak-button hidden" id="playDoctorOriginal">
                            üéß Play Recording
                        </button>
                    </div>
                    
                    <div class="result-box translated">
                        <div class="result-label">For Patient:</div>
                        <div id="doctorTranslated">Translation will appear here...</div>
                    </div>
                    
                    <button class="speak-button hidden" id="speakDoctor">
                        üîä Speak Translation
                    </button>
                </div>
            </div>

            <!-- Status Messages -->
            <div id="statusMessage" class="hidden"></div>

            <!-- Conversation History -->
            <div class="conversation-history">
                <h2>üí¨ Conversation History</h2>
                <div id="conversationList">
                    <p style="text-align: center; color: #666; padding: 20px;">
                        No conversations yet. Start by recording or typing a message.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Language configurations
        const LANGUAGES = {
            'en': { name: 'English', voice: 'en-US', tts: 'en' },
            'ur': { name: 'Urdu', voice: 'ur-PK', tts: 'ur' },
            'hi': { name: 'Hindi', voice: 'hi-IN', tts: 'hi' },
            'ar': { name: 'Arabic', voice: 'ar-SA', tts: 'ar' }
        };

        // Global variables
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let conversation = [];

        // DOM elements
        const patientRecord = document.getElementById('patientRecord');
        const doctorRecord = document.getElementById('doctorRecord');
        const doctorText = document.getElementById('doctorText');
        const submitDoctorText = document.getElementById('submitDoctorText');
        const inputLang = document.getElementById('inputLang');
        const outputLang = document.getElementById('outputLang');
        const openaiKey = document.getElementById('openaiKey');
        const statusMessage = document.getElementById('statusMessage');
        const conversationList = document.getElementById('conversationList');

        // Input method toggle
        document.querySelectorAll('input[name="doctorInput"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const textSection = document.getElementById('textInputSection');
                const voiceSection = document.getElementById('voiceInputSection');
                
                if (this.value === 'text') {
                    textSection.classList.remove('hidden');
                    voiceSection.classList.add('hidden');
                } else {
                    textSection.classList.add('hidden');
                    voiceSection.classList.remove('hidden');
                }
            });
        });

        // Show status message
        function showStatus(message, type = 'info') {
            statusMessage.className = `status-message status-${type}`;
            statusMessage.textContent = message;
            statusMessage.classList.remove('hidden');
            
            setTimeout(() => {
                statusMessage.classList.add('hidden');
            }, 5000);
        }

        // Check browser support
        function checkBrowserSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showStatus('Your browser does not support audio recording. Please use a modern browser.', 'error');
                return false;
            }
            
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showStatus('Speech recognition not supported. OpenAI API key recommended for better results.', 'info');
            }
            
            return true;
        }

        // Store recorded audio for playback
        let recordedAudios = new Map();

        // Start audio recording
        async function startRecording(button, callback) {
            try {
                if (isRecording) {
                    stopRecording();
                    return;
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    
                    // Store audio for playback
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const recordingId = Date.now().toString();
                    recordedAudios.set(recordingId, audioUrl);
                    
                    callback(audioBlob, recordingId);
                    
                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start();
                isRecording = true;
                
                button.textContent = '‚èπÔ∏è Stop Recording';
                button.classList.add('recording');
                showStatus('Recording... Click stop when finished.', 'info');
                
            } catch (error) {
                showStatus('Could not access microphone: ' + error.message, 'error');
            }
        }

        // Stop audio recording
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                document.querySelectorAll('.record-button').forEach(btn => {
                    btn.textContent = btn.id.includes('patient') ? 'üéôÔ∏è Record Patient' : 'üéôÔ∏è Record Clinician';
                    btn.classList.remove('recording');
                });
            }
        }

        // Real-time speech recognition
        function startRealTimeRecognition(language, callback) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                showStatus('Speech recognition not supported in your browser. Please use Chrome or Edge.', 'error');
                callback('');
                return;
            }

            const recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.lang = LANGUAGES[language]?.voice || 'en-US';
            recognition.maxAlternatives = 1;

            showStatus(`Listening in ${LANGUAGES[language]?.name || 'English'}... Speak now!`, 'info');

            recognition.onstart = () => {
                console.log('Speech recognition started');
            };

            recognition.onresult = (event) => {
                let transcript = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    transcript += event.results[i][0].transcript;
                }
                
                if (event.results[0].isFinal) {
                    console.log('Final result:', transcript);
                    callback(transcript.trim());
                } else {
                    // Show interim results
                    console.log('Interim result:', transcript);
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                let errorMessage = 'Speech recognition failed: ';
                
                switch(event.error) {
                    case 'no-speech':
                        errorMessage += 'No speech detected. Please try again.';
                        break;
                    case 'audio-capture':
                        errorMessage += 'Audio capture failed. Check microphone permissions.';
                        break;
                    case 'not-allowed':
                        errorMessage += 'Microphone permission denied.';
                        break;
                    case 'network':
                        errorMessage += 'Network error occurred.';
                        break;
                    default:
                        errorMessage += event.error;
                }
                
                showStatus(errorMessage, 'error');
                callback('');
            };

            recognition.onend = () => {
                console.log('Speech recognition ended');
            };

            // Start recognition
            try {
                recognition.start();
            } catch (error) {
                showStatus('Could not start speech recognition: ' + error.message, 'error');
                callback('');
            }
        }

        // Translate text with smart fallback system
        async function translateText(text, fromLang, toLang) {
            const apiKey = openaiKey.value.trim();
            
            // Skip OpenAI if no API key provided - go straight to free options
            if (!apiKey) {
                showStatus('Using free translation service...', 'info');
                return await translateWithFreeServices(text, fromLang, toLang);
            }
            
            // If API key provided, try OpenAI first but with better error handling
            try {
                return await translateWithOpenAI(text, fromLang, toLang, apiKey);
            } catch (error) {
                // Don't waste credits on retries - go straight to free services
                showStatus('OpenAI unavailable, switching to free services...', 'info');
                return await translateWithFreeServices(text, fromLang, toLang);
            }
        }

        // Free translation services (no API key needed)
        async function translateWithFreeServices(text, fromLang, toLang) {
            try {
                showStatus('Translating with free services...', 'info');
                
                // Try multiple free APIs in order of preference
                const freeApis = [
                    // Microsoft Translator (free tier)
                    {
                        name: 'Microsoft Translator',
                        url: `https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&from=${fromLang}&to=${toLang}`,
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify([{ text: text }]),
                        parse: (data) => data[0]?.translations[0]?.text
                    },
                    // MyMemory Translation API (free, reliable)
                    {
                        name: 'MyMemory',
                        url: `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${fromLang}|${toLang}`,
                        method: 'GET',
                        parse: (data) => {
                            if (data.responseStatus === 200 && data.responseData?.translatedText) {
                                // Filter out low quality translations
                                const translation = data.responseData.translatedText;
                                if (translation !== text && !translation.includes('MYMEMORY WARNING')) {
                                    return translation;
                                }
                            }
                            return null;
                        }
                    },
                    // Lingva Translate (Google Translate proxy)
                    {
                        name: 'Lingva',
                        url: `https://lingva.ml/api/v1/${fromLang}/${toLang}/${encodeURIComponent(text)}`,
                        method: 'GET',
                        parse: (data) => data.translation
                    }
                ];

                // Try each API until one works
                for (let api of freeApis) {
                    try {
                        console.log(`Trying ${api.name}...`);
                        const response = await fetch(api.url, {
                            method: api.method || 'GET',
                            headers: api.headers || {},
                            body: api.body || undefined
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const translation = api.parse(data);
                            
                            if (translation && translation !== text && translation.length > 0) {
                                console.log(`${api.name} translation success:`, translation);
                                showStatus(`Translated successfully with ${api.name}!`, 'success');
                                return translation;
                            }
                        }
                    } catch (apiError) {
                        console.log(`${api.name} failed:`, apiError.message);
                        continue;
                    }
                }
                
                // If all APIs fail, use enhanced dictionary
                throw new Error('All free translation APIs failed');
                
            } catch (error) {
                console.error('Free translation services failed:', error);
                showStatus('Using offline dictionary...', 'info');
                return translateWithDictionary(text, fromLang, toLang);
            }
        }

        // Enhanced offline dictionary
        function translateWithDictionary(text, fromLang, toLang) {
            const translations = {
                // Your spoken phrases - Urdu to English
                'ŸÖ€åÿ±ÿß ⁄ØŸÑÿß ÿÆÿ±ÿßÿ® €Å€í': 'My throat is sore',
                'ŸÖ€åÿ±€í ÿ≥ÿ± ŸÖ€å⁄∫ ÿØÿ±ÿØ €Å€í': 'I have a headache', 
                'ŸÖ€åÿ±ÿß ÿ≥ÿ± ÿØÿ±ÿØ ⁄©ÿ± ÿ±€Åÿß €Å€í': 'My head is hurting',
                'ŸÖ€å⁄∫ ⁄©ŸàŸÜ €ÅŸà⁄∫': 'Who am I', // Your new phrase!
                'ŸÖ€å⁄∫ ÿ®€åŸÖÿßÿ± €ÅŸà⁄∫': 'I am sick',
                'ŸÖÿ¨⁄æ€í ÿ®ÿÆÿßÿ± €Å€í': 'I have fever',
                'ŸÖ€åÿ±ÿß Ÿæ€åŸπ ÿØÿ±ÿØ ⁄©ÿ± ÿ±€Åÿß €Å€í': 'My stomach hurts',
                'ŸÖÿ¨⁄æ€í ⁄©⁄æÿßŸÜÿ≥€å €Å€í': 'I have a cough',
                'ŸÖ€åÿ±€å ÿ≥ÿßŸÜÿ≥ Ÿæ⁄æŸàŸÑ ÿ±€Å€å €Å€í': 'I am short of breath',
                'ŸÖÿ¨⁄æ€í ⁄Ü⁄©ÿ± ÿ¢ ÿ±€Å€í €Å€å⁄∫': 'I feel dizzy',
                'ŸÖ€åÿ±ÿß ⁄ØŸÑÿß ÿ®€åŸπ⁄æ ⁄Ø€åÿß €Å€í': 'My voice is hoarse',
                'ŸÖÿØÿØ ⁄©ÿ±€å⁄∫': 'Please help me',
                '⁄àÿß⁄©Ÿπÿ± ÿµÿßÿ≠ÿ®': 'Doctor',
                'ŸÖ€å⁄∫ Ÿπ⁄æ€å⁄© ŸÜ€Å€å⁄∫': 'I am not well',
                
                // English to Urdu
                'Who am I': 'ŸÖ€å⁄∫ ⁄©ŸàŸÜ €ÅŸà⁄∫',
                'My throat is sore': 'ŸÖ€åÿ±ÿß ⁄ØŸÑÿß ÿÆÿ±ÿßÿ® €Å€í',
                'I have a headache': 'ŸÖ€åÿ±€í ÿ≥ÿ± ŸÖ€å⁄∫ ÿØÿ±ÿØ €Å€í',
                'Take rest': 'ÿ¢ÿ±ÿßŸÖ ⁄©ÿ±€å⁄∫',
                'Drink water': 'ŸæÿßŸÜ€å Ÿæ€åÿ¶€å⁄∫',
                'Take medicine': 'ÿØŸàÿß ŸÑ€å⁄∫',
                'How are you feeling?': 'ÿ¢Ÿæ ⁄©€åÿ≥ÿß ŸÖÿ≠ÿ≥Ÿàÿ≥ ⁄©ÿ± ÿ±€Å€í €Å€å⁄∫ÿü',
                'What is the problem?': '⁄©€åÿß ŸÖÿ≥ÿ¶ŸÑ€Å €Å€íÿü',
                'Where does it hurt?': '⁄©€Åÿß⁄∫ ÿØÿ±ÿØ €Å€íÿü',
                'Since when?': '⁄©ÿ® ÿ≥€íÿü',
                'Open your mouth': 'ÿßŸæŸÜÿß ŸÖŸÜ€Å ⁄©⁄æŸàŸÑ€å⁄∫',
                'Take deep breaths': '⁄Ø€Åÿ±€å ÿ≥ÿßŸÜÿ≥ ŸÑ€å⁄∫',
                'Come back tomorrow': '⁄©ŸÑ ŸàÿßŸæÿ≥ ÿ¢ÿ¶€å⁄∫'
            };
            
            // Try exact match first
            let translation = translations[text];
            
            // Try partial matching with key medical words
            if (!translation) {
                const medicalWords = {
                    'ÿØÿ±ÿØ': 'pain', 'ÿ≥ÿ±': 'head', '⁄ØŸÑÿß': 'throat', 'Ÿæ€åŸπ': 'stomach',
                    'ÿ®ÿÆÿßÿ±': 'fever', '⁄©⁄æÿßŸÜÿ≥€å': 'cough', 'ÿ®€åŸÖÿßÿ±': 'sick'
                };
                
                for (const [urdu, english] of Object.entries(medicalWords)) {
                    if (text.includes(urdu)) {
                        translation = `I have ${english} problem`;
                        break;
                    }
                }
            }
            
            // If still no translation, provide helpful response
            if (!translation) {
                translation = fromLang === 'ur' ? 
                    `[Please provide English translation for: ${text}]` :
                    `[${text} - translation not available]`;
            }
            
            console.log('Dictionary translation:', translation);
            showStatus('Translation from offline dictionary', 'success');
            return translation;
        }

        // Translate using OpenAI (only when API key provided)
        async function translateWithOpenAI(text, fromLang, toLang, apiKey) {
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-3.5-turbo',
                        messages: [{
                            role: 'user',
                            content: `Translate this from ${LANGUAGES[fromLang].name} to ${LANGUAGES[toLang].name}. Return only the translation: "${text}"`
                        }],
                        max_tokens: 100,
                        temperature: 0
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    const errorMessage = errorData.error?.message || `HTTP ${response.status}`;
                    
                    if (response.status === 429) {
                        throw new Error('OpenAI rate limit exceeded. Using free services instead.');
                    } else if (response.status === 401) {
                        throw new Error('Invalid OpenAI API key. Using free services instead.');
                    } else {
                        throw new Error(`OpenAI API error: ${errorMessage}`);
                    }
                }

                const data = await response.json();
                const translation = data.choices[0].message.content.trim();
                showStatus('Translated with OpenAI successfully!', 'success');
                return translation;
            } catch (error) {
                console.error('OpenAI translation failed:', error);
                throw error; // Re-throw to trigger fallback
            }
        }

        // Enhanced Google Translate with better API
        async function translateWithGoogle(text, fromLang, toLang) {
            try {
                showStatus('Translating with Google Translate...', 'info');
                
                // Try multiple translation APIs
                const apis = [
                    // MyMemory API
                    {
                        url: `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${fromLang}|${toLang}`,
                        parse: (data) => data.responseData?.translatedText
                    },
                    // LibreTranslate (if available)
                    {
                        url: `https://libretranslate.de/translate`,
                        method: 'POST',
                        body: JSON.stringify({
                            q: text,
                            source: fromLang,
                            target: toLang,
                            format: 'text'
                        }),
                        headers: { 'Content-Type': 'application/json' },
                        parse: (data) => data.translatedText
                    }
                ];

                for (let api of apis) {
                    try {
                        const response = await fetch(api.url, {
                            method: api.method || 'GET',
                            headers: api.headers || {},
                            body: api.body || undefined
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const translation = api.parse(data);
                            if (translation && translation !== text) {
                                console.log('API translation success:', translation);
                                return translation;
                            }
                        }
                    } catch (apiError) {
                        console.log('API failed, trying next...', apiError);
                        continue;
                    }
                }
                
                throw new Error('All translation APIs failed');
                
            } catch (error) {
                console.error('Online translation failed:', error);
                showStatus('Online translation failed, using offline dictionary...', 'info');
                
                // Enhanced offline dictionary with exact phrase matching
                const translations = {
                    // Urdu to English - exact phrases you're saying
                    'ŸÖ€åÿ±ÿß ⁄ØŸÑÿß ÿÆÿ±ÿßÿ® €Å€í': 'My throat is sore',
                    'ŸÖ€åÿ±€í ÿ≥ÿ± ŸÖ€å⁄∫ ÿØÿ±ÿØ €Å€í': 'I have a headache',
                    'ŸÖ€åÿ±ÿß ÿ≥ÿ± ÿØÿ±ÿØ ⁄©ÿ± ÿ±€Åÿß €Å€í': 'My head is hurting',
                    'ŸÖ€å⁄∫ ÿ®€åŸÖÿßÿ± €ÅŸà⁄∫': 'I am sick',
                    'ŸÖÿ¨⁄æ€í ÿ®ÿÆÿßÿ± €Å€í': 'I have fever',
                    'ŸÖÿ¨⁄æ€í ÿØÿ±ÿØ €ÅŸà ÿ±€Åÿß €Å€í': 'I am in pain',
                    'ŸÖ€åÿ±ÿß Ÿæ€åŸπ ÿØÿ±ÿØ ⁄©ÿ± ÿ±€Åÿß €Å€í': 'My stomach hurts',
                    'ŸÖÿ¨⁄æ€í ŸÖÿ™ŸÑ€å ÿ¢ ÿ±€Å€å €Å€í': 'I feel nauseous',
                    'ŸÖ€åÿ±€å ÿ≥ÿßŸÜÿ≥ Ÿæ⁄æŸàŸÑ ÿ±€Å€å €Å€í': 'I am short of breath',
                    'ŸÖ€åÿ±ÿß ⁄ØŸÑÿß ÿ®€åŸπ⁄æ ⁄Ø€åÿß €Å€í': 'My voice is hoarse',
                    'ŸÖÿ¨⁄æ€í ⁄©⁄æÿßŸÜÿ≥€å €Å€í': 'I have a cough',
                    'ŸÖ€åÿ±€å ÿ¢ŸÜ⁄©⁄æ ŸÖ€å⁄∫ ÿØÿ±ÿØ €Å€í': 'My eye hurts',
                    'ŸÖ€åÿ±ÿß ⁄©ÿßŸÜ ÿØÿ±ÿØ ⁄©ÿ± ÿ±€Åÿß €Å€í': 'My ear hurts',
                    'ŸÖÿØÿØ ⁄©ÿ±€å⁄∫': 'Please help me',
                    '⁄àÿß⁄©Ÿπÿ± ÿµÿßÿ≠ÿ®': 'Doctor',
                    
                    // English to Urdu
                    'My throat is sore': 'ŸÖ€åÿ±ÿß ⁄ØŸÑÿß ÿÆÿ±ÿßÿ® €Å€í',
                    'I have a headache': 'ŸÖ€åÿ±€í ÿ≥ÿ± ŸÖ€å⁄∫ ÿØÿ±ÿØ €Å€í',
                    'Take rest and drink water': 'ÿ¢ÿ±ÿßŸÖ ⁄©ÿ±€å⁄∫ ÿßŸàÿ± ŸæÿßŸÜ€å Ÿæ€åÿ¶€å⁄∫',
                    'You need medicine': 'ÿ¢Ÿæ ⁄©Ÿà ÿØŸàÿß ⁄©€å ÿ∂ÿ±Ÿàÿ±ÿ™ €Å€í',
                    'How are you feeling?': 'ÿ¢Ÿæ ⁄©€åÿ≥ÿß ŸÖÿ≠ÿ≥Ÿàÿ≥ ⁄©ÿ± ÿ±€Å€í €Å€å⁄∫ÿü',
                    'Take this medicine': '€å€Å ÿØŸàÿß ŸÑ€å⁄∫',
                    'Come back tomorrow': '⁄©ŸÑ ŸàÿßŸæÿ≥ ÿ¢ÿ¶€å⁄∫',
                    'What is the problem?': '⁄©€åÿß ŸÖÿ≥ÿ¶ŸÑ€Å €Å€íÿü',
                    'Where does it hurt?': '⁄©€Åÿß⁄∫ ÿØÿ±ÿØ €Å€íÿü',
                    'Since when?': '⁄©ÿ® ÿ≥€íÿü',
                    'Show me': 'ŸÖÿ¨⁄æ€í ÿØ⁄©⁄æÿßÿ¶€å⁄∫',
                    'Open your mouth': 'ÿßŸæŸÜÿß ŸÖŸÜ€Å ⁄©⁄æŸàŸÑ€å⁄∫',
                    'Take deep breaths': '⁄Ø€Åÿ±€å ÿ≥ÿßŸÜÿ≥ ŸÑ€å⁄∫'
                };
                
                // Try exact match first
                let translation = translations[text];
                
                // If no exact match, try partial matching
                if (!translation) {
                    for (const [key, value] of Object.entries(translations)) {
                        if (text.includes(key) || key.includes(text)) {
                            translation = value;
                            break;
                        }
                    }
                }
                
                // If still no match, indicate translation needed
                if (!translation) {
                    translation = `[Translation needed: ${text}]`;
                }
                
                console.log('Dictionary translation:', translation);
                return translation;
            }
        }

        // Text-to-speech
        function speakText(text, language) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = LANGUAGES[language]?.voice || 'en-US';
                utterance.rate = 0.8;
                speechSynthesis.speak(utterance);
            } else {
                showStatus('Text-to-speech not supported in your browser', 'error');
            }
        }

        // Add conversation item
        function addToConversation(role, original, translated, timestamp = Date.now(), recordingId = null) {
            const item = { role, original, translated, timestamp, recordingId };
            conversation.push(item);
            renderConversation();
        }

        // Play recorded audio
        function playRecordedAudio(recordingId) {
            const audioUrl = recordedAudios.get(recordingId);
            if (audioUrl) {
                const audio = new Audio(audioUrl);
                audio.play().catch(e => {
                    showStatus('Could not play recording: ' + e.message, 'error');
                });
            }
        }

        // Render conversation history
        function renderConversation() {
            if (conversation.length === 0) {
                conversationList.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No conversations yet. Start by recording or typing a message.</p>';
                return;
            }

            conversationList.innerHTML = conversation.map((item, index) => `
                <div class="conversation-item ${item.role.toLowerCase()}">
                    <div class="conversation-meta">
                        <span><strong>${item.role}</strong></span>
                        <span>${new Date(item.timestamp).toLocaleTimeString()}</span>
                    </div>
                    <div class="conversation-content">
                        <div><strong>Original:</strong> ${item.original}</div>
                        <div><strong>Translated:</strong> ${item.translated}</div>
                        <div style="margin-top: 10px;">
                            ${item.recordingId ? `<button class="speak-button" onclick="playRecordedAudio('${item.recordingId}')">üéß Play Original</button>` : ''}
                            <button class="speak-button" onclick="speakText('${item.translated}', '${item.role === 'Patient' ? outputLang.value : inputLang.value}')">
                                üîä Speak Translation
                            </button>
                        </div>
                    </div>
                </div>
            `).reverse().join('');
        }

        // Event listeners
        patientRecord.addEventListener('click', () => {
            if (!isRecording) {
                // Start recording and real-time speech recognition
                startRecording(patientRecord, async (audioBlob, recordingId) => {
                    // Audio recorded for playback, but we use live speech recognition for transcription
                });
                
                // Start live speech recognition immediately
                startRealTimeRecognition(inputLang.value, async (transcript) => {
                    if (transcript) {
                        showStatus('Processing transcript...', 'info');
                        document.getElementById('patientOriginal').textContent = transcript;
                        
                        // Get current recording ID from the stored audios
                        const recordingKeys = Array.from(recordedAudios.keys());
                        const currentRecordingId = recordingKeys[recordingKeys.length - 1];
                        
                        if (currentRecordingId) {
                            document.getElementById('playPatientOriginal').classList.remove('hidden');
                            document.getElementById('playPatientOriginal').onclick = () => playRecordedAudio(currentRecordingId);
                        }
                        
                        const translation = await translateText(transcript, inputLang.value, outputLang.value);
                        document.getElementById('patientTranslated').textContent = translation;
                        document.getElementById('speakPatient').classList.remove('hidden');
                        
                        addToConversation('Patient', transcript, translation, Date.now(), currentRecordingId);
                        showStatus('Patient message processed successfully!', 'success');
                    } else {
                        showStatus('No speech detected. Please try again.', 'error');
                    }
                });
            } else {
                stopRecording();
            }
        });

        doctorRecord.addEventListener('click', () => {
            if (!isRecording) {
                // Start recording and real-time speech recognition
                startRecording(doctorRecord, async (audioBlob, recordingId) => {
                    // Audio recorded for playback
                });
                
                // Start live speech recognition
                startRealTimeRecognition(outputLang.value, async (transcript) => {
                    if (transcript) {
                        showStatus('Processing transcript...', 'info');
                        document.getElementById('doctorOriginal').textContent = transcript;
                        
                        const recordingKeys = Array.from(recordedAudios.keys());
                        const currentRecordingId = recordingKeys[recordingKeys.length - 1];
                        
                        if (currentRecordingId) {
                            document.getElementById('playDoctorOriginal').classList.remove('hidden');
                            document.getElementById('playDoctorOriginal').onclick = () => playRecordedAudio(currentRecordingId);
                        }
                        
                        const translation = await translateText(transcript, outputLang.value, inputLang.value);
                        document.getElementById('doctorTranslated').textContent = translation;
                        document.getElementById('speakDoctor').classList.remove('hidden');
                        
                        addToConversation('Doctor', transcript, translation, Date.now(), currentRecordingId);
                        showStatus('Clinician message processed successfully!', 'success');
                    } else {
                        showStatus('No speech detected. Please try again.', 'error');
                    }
                });
            } else {
                stopRecording();
            }
        });

        submitDoctorText.addEventListener('click', async () => {
            const text = doctorText.value.trim();
            if (!text) {
                showStatus('Please enter a message first.', 'error');
                return;
            }
            
            showStatus('Translating message...', 'info');
            document.getElementById('doctorOriginal').textContent = text;
            
            const translation = await translateText(text, outputLang.value, inputLang.value);
            document.getElementById('doctorTranslated').textContent = translation;
            document.getElementById('speakDoctor').classList.remove('hidden');
            
            addToConversation('Doctor', text, translation);
            doctorText.value = '';
            showStatus('Message translated successfully!', 'success');
        });

        document.getElementById('speakPatient').addEventListener('click', () => {
            const text = document.getElementById('patientTranslated').textContent;
            speakText(text, outputLang.value);
        });

        document.getElementById('speakDoctor').addEventListener('click', () => {
            const text = document.getElementById('doctorTranslated').textContent;
            speakText(text, inputLang.value);
        });

        // Initialize app
        function initializeApp() {
            if (!checkBrowserSupport()) {
                return;
            }
            
            showStatus('Healthcare Translation Assistant ready! ü©∫', 'success');
        }

        // Start the app
        initializeApp();
    </script>
</body>
</html>